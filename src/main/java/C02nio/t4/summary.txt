1、SerialGC:
这种GC比较容易理解，暂停所有的业务线程（STW），串行的执行垃圾回收（年轻代使用标记-复制，老年代使用标记-清除-整理）。

2、ParallelGC:
为了改进串行GC无法利用现代计算机多核来提高吞吐量的缺陷，采用并行的方式在STW的时候进行垃圾回收，多核计算机上GC时间明显缩短。

3、CMS GC:
为了改进前两者GC的STW过长不适用低延迟业务，希望改进减少STW时间。通过对GC步骤进一步拆分步骤、流水化，只在必要步骤上STW，从而达到GC时业务降低延迟的效果。
还有一点区别于前两者，是其在老年代采用标记-清除算法。

4、G1 GC:
在上述GC的基础之上，由于GC时间一定程度上还是和对象数量成线性相关，于是提出了GC时间可控可配置的要求。
通过对堆内存分块，根据堆内存收集的信息和启动配置信息（期望GC延迟时间），来决定进行垃圾回收的块数量，以达到期望的GC延迟时间。
另外除了整个老年代不会一次性清除外，单个内存块同样不需要一次性完全清除，只要清除达到一定比例，就会停止。都是为了GC时间可配置服务。
还会收集每块信息有限处理垃圾多的块，我的理解是这个特性应该是在老年代。因为不存在处理部分Eden区的情况。

5、GC总结
以上GC都是建立在分代基础之上，进行部分GC时，由于代间引用的存在，标记根对象集合时，需要通过特殊处理。